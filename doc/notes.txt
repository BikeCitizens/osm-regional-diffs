Regional Diffs
==============

Minutely Diffs -> Crop (auf eine bestimmte Region) -> alle ways extrahieren -> testen ob way teil einer bicylce relation ist.

Minutely Diffs
--------------
download von http://planet.openstreetmap.org/replication/minute/000/881/

Unter http://planet.openstreetmap.org/replication/minute/state.txt
gibt es eine sech:`sequenceNumber` die anzeigt welches File das letzte
minutely diff ist.

Man muss sich merken, welche sequenceNumber man als letztes
heruntergeladen hat und - für den Fall, dass man innerhalb des
vorgegenben Intervalls eine sequnceNumber verpasst hat - alle
dazwischen liegende Diffs ebenfalls laden.

Wenn das Skript als deamon läuft, dann kann man ein Intervall zw. 30s
und 59s wählen um sicher zu gehen, dass man keine Diff verpasst.

Einzelne Changesets
-------------------
download via http://www.openstreetmap.org/api/0.6/changeset/22466785/download

Crop (auf eine bestimmte Region)
--------------------------------
mit osmosis (aptitude install osmosis)
Usage auf http://wiki.openstreetmap.org/wiki/Osmosis/Detailed_Usage
vorarlberg-polygon als .poly-file mittels JOSM aus der Grenz-Relation abspeichern

Cleaned hourly changeset (solved merge conflicts)
-------------------------------------------------

osmosis --read-xml-change 291.osc outPipe.0="change" --simplify-change inPipe.0="change" --write-xml-change 291-clean.osc

Umwandeln eines Changesets in ein OSM-File
------------------------------------------

osmosis --read-empty outPipe.0="mypipe" --read-xml-change 291-clean.osc outPipe.0="change" --apply-change inPipe.0="mypipe" inPipe.1="change" --write-xml 291.osm

Crop des OSM-Files auf ein bounding polygon (vorarlberg.poly)
-------------------------------------------------------------

osmosis --read-xml file="291.osm" outPipe.0="change" --bounding-polygon inPipe.0="change" file="vorarlberg.poly" --write-xml 291-cropped.osm

Putting it all together (clean (from merge conflicts) -> convert osc to osm -> crop osm to vorarlberg
-----------------------------------------------------------------------------------------------------

osmosis --read-xml-change 291.osc outPipe.0="change" --simplify-change inPipe.0="change" outPipe.0="cleaned" --read-empty outPipe.0="empty" --apply-change inPipe.0="empty" inPipe.1="cleaned" outPipe.0="osm" --bounding-polygon inPipe.0="osm" file="vorarlberg.poly" --write-xml -

Way extrahieren
---------------

aus dem (cropted) minutely diff nach "way id" greppen
via der way-id den way aus http://www.openstreetmap.org/api/0.6/way/30160091 als XML runterladen

Download Map von Vorarlberg
---------------------------

http://overpass-api.de/api/map?bbox=9.5375,46.8417,10.2421,47.5968

http://overpass.osm.rambler.ru/cgi/interpreter?data=rel(46.8417,9.5375,47.5968,10.2421);out;

Relationen finden in der die "way id" enthalten sind
----------------------------------------------------

Mögliche Lösungen:

* aus der gegeben Region alle Relationen auflisten und schauen ob die "way id" in einer Relation enthalten ist
    die Relationen regelmäßig mittels overpass herunterladen
* "way id" über die overpass API abfragen und schauen ob die Relation geliefert wird.
    http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide#Relations_2

Retrieve relation ids of way with overpass API
----------------------------------------------

* http://overpass-api.de/api/convert?data=way%2830245439%29%3B%0A%3C%3B%0Aout%20ids%3B&target=mapql
* http://overpass-turbo.eu/s/3TM

::
  way(30245439);
  <;
  out ids;

For multiple way ids do the following::

  way(31347480);
  <;
  out ids;
  way(30245439);
  <;
  out ids;

* http://overpass-turbo.eu/s/3TP

Find relation ids which are bicylce routes
------------------------------------------

::
  relation[route=bicycle];
  out ids;

To test a list of relations ids::

  relation(421088)[route=bicycle];
  out ids;
  relation(937246)[route=bicycle];
  out ids;
  relation(1745069)[route=bicycle];
  out ids;
  relation(1753434)[route=bicycle];
  out ids;
  relation(1753469)[route=bicycle];
  out ids;
  relation(1820015)[route=bicycle];
  out ids;
  relation(1820016)[route=bicycle];
  out ids;
  relation(1758896)[route=bicycle];
  out ids;
  relation(3812436)[route=bicycle];
  out ids;
  relation(3814846)[route=bicycle];
  out ids;

To find all bicycle route-relations from a list of way id::

  (
    way(30245439);
    way(31347480);
  );
  (<;)->.routes;
  relation.routes[route="bicycle"];
  out ids;

*  http://overpass-turbo.eu/s/3TT

Because overpass QL works with the default set *_* naming the set *routes* was not necessary.
I could have been written simpler (but less readable)::

  (
    way(30245439);
    way(31347480);
  );
  <;
  relation._[route="bicycle"];
  out ids;

Show only ways (from a given list of ways) which are part of a bicycle route
----------------------------------------------------------------------------

::

  (
    way(30245439); // Unterer Illrain (highway=track / bicycle=yes)
    way(31347480); // Gielgenstraße (highway = residental) not part of bicycle route
    way(60638588); // part of 3 bicycle routes
    way(200568747); // motorway
  );
  rel(bw)[route="bicycle"]->.cycleroutes;
  // (.cycleroutes >;)->.cycleways;
  way(r.cycleroutes)->.cycleways;
  (
    way.cycleways(30245439);
    way.cycleways(31347480);
    way.cycleways(60638588);
    way.cycleways(200568747);
  )->.result;
  .result out meta;

*union* the ways to a set. *rel(bw)* will select relations that have way members from the input set.
*[route="bicylce"]* will find all relations with *route=bicycle* and the set is saved in the set *.cycleroutes*.
*.cycleroutes >;* recurses down the from the given relations and this output will be saved in the set *.cycleways*.

.. note::

  *(.cycleroutes >;)->.cycleways;* would provide all nodes too. A more effient
  way for our task is to select only the parent ways for all nodes from the input
  set with *way(bn*);

Problem:
ways ohne node-änderungen (nur tags) schmeisst der osmosis-crop-befehl raus.

wenn wir wget http://www.openstreetmap.org/api/0.6/changeset/24005065
dann kriegen wir das XML mit den changeset-tags, wo min_max lon/lat drinstehen

so problem: ways ohne nodes, vorgehensweise:
 * osmosis-toolchain bis auf schritt b-poly durchführen
 * filtern nach unseren benötigten tag-kombinationen
  hw=cw || hw=tr|path|fw|serv && (( bicy=¬false || access=¬false)
    false ≙ private|no
    true ≙ yes|designated|permissive|official|public

--read-xml input.osm \
  --tf accept-ways highway=* \
  --tf reject-ways highway=motorway,motorway_link,trunk,trunk_link,bus_guideway,raceway \
  --used-node \
  --write-xml output.osm

 * von überbleibenden ways jeweils den ersten node runterladen und ins .osm.xml einfügen
 * dann mit osmosis beschneiden

Problem mit Relations:
  was ist, wenn jemand einen way aus der Bundesstraße löscht?
    → dann wird die Relation modified, und wir kriegens mit.

Seine vorgangsweise:
  croppen
  alle ways schaun ob in [route="bicycle"] ->.bikerouteways → needs alle hw's !motorway-etc
  alle ways schaun ob hw=cw -> .cycleways;
  alle rels schaun ob [route="bicycle"] -> .bikerouts → TODO kann mit osmosis gemacht werden → DONE werden nur diese rels durchgelassen
  alle ways schaun ob hw=rest+bic=ja → .bicycleallowed → FIXME könnte mit osmosis gemacht werden
  get ALLE results von overpass API als osm.xml zurück
  parse und printe.

besser: 
  nur schaun ob in [route="bicycle"] via overpass.
  Rest müsste via osmosis gehen!
    direkt aus osmosis folgendes nehmen:
    • alle rels [route="bicycle"]
    • alle hw=cw; hw=rest+bic=ja
  → doppelte rausfiltern wie?
      overpass kann das... ( () (union) )
        das ist genau das was er macht...
          am einfachsten nur den Input verkleinern
            wir müssen sowieso alle ways an overpass schicken, da machen die 10% doppelten und 1% rels extra auch nix aus
→ Todo:
  filtern mit osmosis, ev. mehrere steps
    1. nur die typen die interessieren
  dann fehlende way-koordinaten nodes hinzufügen (get a list of nodes via overpass)
  croppen
    (ev: 2. satz filtern nach nur cw=erlaubt ways mittels osmosis, damit die overpass-server weniger zu tun haben)
  große (oder ev. etwas verkleinerte) overpass-query absetzen

vars:    self.__content_diff ist die antwort der overpass API, aus der das Ergebnis generiert wird

TO TEST overpass QL if leer.

TO TEST if rel modified with no members supplied (no spatial information)
  testcase: sortiere nur Murradweg um

TO TEST __readWayNodes liest ja jetzt nur mehr das von osmosis von osc in XML umgewandelte File - sind im XML die deleted items noch drin?
  NEIN - FUCK.
    beeinflusst:
      • nodes, die in ways waren die in [route="bicycle"] ->.bikerouteways drin waren - NEIN, da way dann auch modified wurde
      • gelöschte Ways - NEIN, da Rel dann auch modifiziert würde (kA ob server objekte löschen lässt, wenn in rel vorhanden. sollte aber normalerweise kein Editor zulassen)
        · wär aber klass, in einer übersicht den status anzuzeigen
      • alleinstehende cws, die nicht in einer Relation sind.
      • deletete Relations (!)
  abhilfe:
    per regex <deleted> → <modified> im osc NACH --simplify-change - Schritt. -OK
